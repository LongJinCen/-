// 解决的问题: 在一个无序数组中，找到一个第 k 小(大)的数
// 无序排序： O(N)


// 可以使用 荷兰国际问题，每次随机选择划分值，如果中间的等于区域的 index 小于 k, 那么再使用同样的方法去划分右边
// 反之，去划分左边，知道等于区域的 index === k
// T(N) = T(N / 2) + O(N) 根据 master 公式，长期期望为 O(N)


// bfprt: 严格 O(N)，不存在前面荷兰国旗问题最好情况和最坏情况。
// 相比于使用荷兰国旗问题，优化了随机选择划分值，即不是随机选择划分值
// 步骤:
// 1): 将数组划分： 每1个一组（不用实际划分为多个数组） O(1)
// 2): 每个数组组内排序：由于数据规模小，每一个排序 O(1)，总共 N /5 个， 所以总的为 O(N)
// 3): 将每组里面的中位数取出来，形成一个新的数组，同样按照上面的步骤，数据规模为 T(N /5 ),直到数据规模为 5 一下，直接返回中位数
// 4)：将上面得到的中位数 作为荷兰国旗问题的划分值，划分，经证明，左边的为 T((3/10)N) 或者 T((7/10)N)，右边也是
// 5)： 将荷兰国旗问题返回的新数组，同样进行从上面的 第一步 到 第四步，直到找到合适的 k
// 6)   总的时间复杂度为 T(N) = T(N/5) + T(7/10 N) + O(N), 经证明，时间复杂度为 O(N)