// 解决的问题：在一个数组中，想知道所有的数，左边离得最近的比它大的和右边离得最近的比它大的数, 用 O(N) 的方法
// 单调栈: 从栈底到栈顶为从大到小的
// 流程：遍历数组, 更新栈。更新过程和窗口的双端队列更新相似
//  1): 如果比栈顶的数小，那么就继续入栈
//  2): 如果比栈顶数大，那么使栈顶的数出栈的为右边离得最近的大的数，栈顶数下一层的数为左边离得最近的大的数
//  3): 如果出栈的时候，到栈底，那么栈底的左边离得最近的大的数为 null
//  4): 如果到最后，栈未空，那么要全部清空，清空的过程中，由于没有一个数使栈顶的数出栈，那么每一个栈顶的数的右边离得最近的大数为 null
//  5): 如果当前的数和栈顶的数大小相等，那么将他们放在栈的同一个位置，都记录他们的下标

