// 解决的问题: 1. 给定两个 str1 和 str2，想知道str1的一个子串是否和 str2 是一样的，如果是
// 2. 求某一棵树是否是一棵树的子树，首先将两个树序列化，空一定要用 # 来表示，然后就转换为求一个字符串是否是另一个字符串的子串
// 那么返回 str2 开始的位置
// 3. 给一个字符串，只能在字符串末尾添加字符，求最短添加多少个字符能够在出现一个同样的字符串。例如abcabc -> abcacbacb,需要再添加三个字符
// 思路是先求出整个字符串的最长前缀和最长后缀的长度，然后把前缀到末尾的字符再添加一遍就好了，例如abcabc 最长前缀和后缀为3，那么把从位置3到末尾的字符再添加一遍就好了
// str1.indexOf(str2)和这个方法实现的差不多

// 子序列可以连续也可以不连续, 子串是连续的

// 笨办法: str1 从 0 位置开始往下配 str2, 如果配不上，那么移到 1 位置以及往下配，知道配对成功
// 或者 str1 走完，这个是笨办法，都能想到，但是时间复杂度 O(m * n)。每一个配的过程，都是独立的，
// 没有一个加速的信息。
// kmp 的算法就是让前面过程的信息，去加速后面，将前面的利用起来

// 在学习 kmp 之前，先建立一个概念：在一个字符串中，一个字符之前的字符串最长前缀和最长后缀
// 的匹配长度。限制: 前缀不能包含最后一个字符，后缀不能包含第一个字符，即最长长度为前面的字符串长度减一
// 例子: abcabcd 。让我们来看 d 这个字符最长前缀和最长后缀的匹配长度
// 当 长度取 2 时，前缀为 ac, 后缀为 bc，不相等，当长度取 3 时，前缀为 abc, 后缀为 abc,相等，
// 当长度取 5时，分别为 abcab、bcabc,不相等，此时不能再往下取，所以 b 字符的最长前缀和最长后缀
// 的匹配长度为 3

// 获取 str 的每一个位置的最长公共前缀和最长公共后缀
// 思路: 每一个位置都借助前一个位置以及计算出来的值来加速这个过程。
// 假设当前位置为 n, n - 1 位置的最长前缀后缀的长度值为 m, 第一：去找 m 位置的 字符是否和 n 位置的相等，如果等，那么 n 位置的最长前缀后缀的值为 m + 1
// 第二：如果不等，那么 根据 next 数组，取得 next[m] 的最长公共前缀后缀的值为 k, 那么去找 k位置的值是否和 n 位置的字母一样，如果一样那么next[n] = k,
// ，如果不一样，按照第二步继续，知道next[...] = -1，即到达第一个位置，此时 next[...] = 0
function getNextArray(strArr) {
    if (strArr.length === 1) {
        return [-1]
    }
    // 第一个位置没有最长公共前缀和最长公共后缀，所以为 -1, 第二个位置为 0
    const next = [-1, 0]
    let i = 2
    // 通过 next 获得，表示最长前缀后缀的长度为 cn。也表示前缀的后一个位置的字符，因为位置从 0 开始的。
    let cn = 0
    // 从第二个位置开始计算每一个位置的值
    while (i < next.length) {
        // 如果前一个位置和前缀的后一个位置的字符相等，那么当前位置的最长公共前缀和后缀长度为 前一个位置的 cn 加一
        if (strArr[i - 1] == strArr[cn]) {
            next[i++] = ++cn
        // 如果前一个位置和前缀的后一个位置的字符不相等，那么前缀的位置改变成以该位置表示的最长前缀后缀的值
        } else if (cn > 0) {
            cn = next[cn]
        // 如果一直没有找到相等的位置，到达 cn = -1的时候，i 位置的最长前缀后缀为 0
        } else {
            next[i++] = 0
        }
    }
    return next
}

// kmp(getIndexOf): 参考 kmp.png
function getIndexOf(str1, str2) {
    if (str1.length === 0 || str2 === 0 || str1.length < str2.length) {
        return -1
    }
    const str1Arr = str1.split('')
    const str2Arr = str2.split('')
    const i1 = 0, i2 = 0
    //先把 str2 的每个位置的最长前缀和最长后缀的匹配长度求出来, 返回一个数组.
    const next = getNextArray(str2Arr)
    // 循环遍历
    while (i1 < str1Arr.length && i2 < str2Arr.length) {
        // 如果两个字符串的字符相等，那么一直往下走
        if (str1Arr[i1] === str2Arr[i2]) {
            i1++
            i2++
        // 如果不相等，说明此时位于str2的第一个位置，且第一个位置不相等，所以 i1 下移一位
        } else if (next[i2] == -1) {
            i1++
        // 如果不相等，且不位于str2的第一个位置，那么 i2 往后推到公共前缀的后一个位置
        } else {
            i2 = next[i2]
        }
    }
    // 最后如果i2走到了最后，说明能找到该字符串，所以需要用 i1 此时的位置减去 str2.length || i2，的值能得到 str2 在 str1 中开始的位置
    return i2 == str2.length ? i1 - i2 : -1
}