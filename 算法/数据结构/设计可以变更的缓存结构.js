// 设计可以变更的缓存结构(LRU)
// 设计一种缓存结构，该结构在构造时确定大小，假设大小为k， 并有两个功能
// set(key, value) : 将记录插入该结构
// get(key): 返回key对应的value值
// 要求: 1) set 和 get  的时间复杂度为 O(1)
//      2) 某个key的set或get操作一旦发生，认为这个Key的记录成了最经常使用的（放到双向链表的尾部）
//      3) 当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的(双向链表的头部)

//思路： 准备一个hashmap(key为key，value为该node节点) 和 一个双向链表(假设头部的优先级最低)。
// set 时：先检查双向链表的长度是否超过给定的 k，如果超过了，需要将双向链表的头部的节点(最不经常使用的节点)删除，并且需要把 hashmap当中的该节点删除，
//         如果没有超过长度, 然后以key 为 key， 并构建一个新的node作为 value 存入hashmap，node存储着key和value。同时将它作为优先级最高的
//         节点挂在双向链表的结尾。

// get 时：直接在 hashmap 里面拿到该 node 节点，直接操作该节点，不需要去双向链表中操作，因为该节点就是双向链表中的引用。
// 然后在双向链表中先将其删除，然后将其挂在双向链表的末尾，作为最高优先级


// 缓存算法 LFU